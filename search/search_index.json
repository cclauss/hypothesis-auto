{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Read Latest Documentation - Browse GitHub Code Repository An extension for the hypothesis project that enables fully automatic tests for type annotated functions: from hypothesis_auto import auto_test def add ( number_1 : int , number_2 : int = 1 ) -> int : return number_1 + number_2 auto_test ( add ) # 50 property based scenerios are generated and ran against add auto_test ( add , _auto_runs = 1_000 ) # Let's make that 1,000 from hypothesis_auto import auto_test def divide ( number_1 : int , number_2 : int ) -> int : return number_1 / number_2 auto_test ( divide ) -> 1012 raise the_error_hypothesis_found 1013 1014 for attrib in dir ( test ): < ipython - input - 2 - 65 a3aa66e9f9 > in divide ( number_1 , number_2 ) 1 def divide ( number_1 : int , number_2 : int ) -> int : ----> 2 return number_1 / number_2 3 0 / 0 ZeroDivisionError : division by zero auto_test ( divide , _auto_allow_exceptions = ( ZeroDivisionError , )) For the full set of parameters you can pass into auto_test see its API reference documentation . Why Create hypothesis-auto? I wanted a no/low resistance way to start incorporating property based tests across my projects. Such a solution, that also encouraged the use of type hints, was a win/win for me. I hope you too find hypothesis-auto useful! ~Timothy Crosley","title":"Home"},{"location":"#why-create-hypothesis-auto","text":"I wanted a no/low resistance way to start incorporating property based tests across my projects. Such a solution, that also encouraged the use of type hints, was a win/win for me. I hope you too find hypothesis-auto useful! ~Timothy Crosley","title":"Why Create hypothesis-auto?"},{"location":"reference/hypothesis_auto/","text":"Module hypothesis_auto View Source from hypothesis_auto.tester import auto_test , auto_test_module __version__ = \"0.0.4\" Sub-modules hypothesis_auto.tester","title":"Index"},{"location":"reference/hypothesis_auto/#module-hypothesis_auto","text":"View Source from hypothesis_auto.tester import auto_test , auto_test_module __version__ = \"0.0.4\"","title":"Module hypothesis_auto"},{"location":"reference/hypothesis_auto/#sub-modules","text":"hypothesis_auto.tester","title":"Sub-modules"},{"location":"reference/hypothesis_auto/tester/","text":"Module hypothesis_auto.tester View Source from inspect import isfunction from types import ModuleType from typing import Callable , Optional , Tuple , Union , get_type_hints from hypothesis.strategies import SearchStrategy , builds , just from pydantic import BaseModel def auto_test ( _auto_function : Callable , * args , _auto_allow_exceptions : Union [ Tuple [ BaseException ], Tuple ] = (), _auto_runs : int = 50 , _auto_verify : Optional [ Callable ] = None , ** kwargs ) -> None : \"\"\"A simple utility function for hypothesis that enables fully automatic testing for a type hinted callable, including return type verification. By default auto_test uses type annotations to automatically decide on strategies via the hypothesis builds strategy. You can override individual strategies by passing them in under the corresponding `*arg` or `**kwarg` OR you can pass in specific values that must be used for certain parameters while letting others be auto generated. All `*arg` and `**kwargs` are automatically passed along to `hypothesis.strategies.builds` to enable this. Non strategies are automatically converted to strategies using `hypothesis.strategies.just`. Except for the following options: - *_auto_allow_exceptions*: A tuple of exceptions that are acceptable for the function to raise and will no be considered a test error. - *_auto_runs*: Number of strategies combinations to run the given function against. - *_auto_verify*: An optional callback function that will be called to allow custom verification. of the functions return value. The callback function should raise an AssertionError if the return value does not match expectations. \"\"\" return_type = get_type_hints ( _auto_function ) . get ( \"return\" , None ) strategy_args = [ arg if isinstance ( arg , SearchStrategy ) else just ( arg ) for arg in args ] strategy_kwargs = { name : value if isinstance ( value , SearchStrategy ) else just ( value ) for name , value in kwargs . items () } strategy = builds ( _auto_function , * strategy_args , ** strategy_kwargs ) for _ in range ( _auto_runs ): try : result = strategy . example () except _auto_allow_exceptions : # type: ignore continue if return_type : class ReturnModel ( BaseModel ): __annotations__ = { \"returns\" : return_type } ReturnModel ( returns = result ) if _auto_verify : _auto_verify ( result ) def auto_test_module ( module : ModuleType ) -> None : \"\"\"Attempts to automatically test every public function within a module.\"\"\" for attribute_name in dir ( module ): if not attribute_name . startswith ( \"_\" ): attribute = getattr ( module , attribute_name ) if isfunction ( attribute ): auto_test ( attribute ) Functions auto_test def auto_test ( _auto_function : Callable , * args , _auto_allow_exceptions : Union [ Tuple [ BaseException ], Tuple ] = (), _auto_runs : int = 50 , _auto_verify : Union [ Callable , NoneType ] = None , ** kwargs ) -> None A simple utility function for hypothesis that enables fully automatic testing for a type hinted callable, including return type verification. By default auto_test uses type annotations to automatically decide on strategies via the hypothesis builds strategy. You can override individual strategies by passing them in under the corresponding *arg or **kwarg OR you can pass in specific values that must be used for certain parameters while letting others be auto generated. All *arg and **kwargs are automatically passed along to hypothesis.strategies.builds to enable this. Non strategies are automatically converted to strategies using hypothesis.strategies.just . Except for the following options: _auto_allow_exceptions : A tuple of exceptions that are acceptable for the function to raise and will no be considered a test error. _auto_runs : Number of strategies combinations to run the given function against. _auto_verify : An optional callback function that will be called to allow custom verification. of the functions return value. The callback function should raise an AssertionError if the return value does not match expectations. View Source def auto_test ( _auto_function : Callable , * args , _auto_allow_exceptions : Union [ Tuple [ BaseException ], Tuple ] = () , _auto_runs : int = 50 , _auto_verify : Optional [ Callable ] = None , ** kwargs ) -> None : \"\"\" A simple utility function for hypothesis that enables fully automatic testing for a type hinted callable , including return type verification . By default auto_test uses type annotations to automatically decide on strategies via the hypothesis builds strategy . You can override individual strategies by passing them in under the corresponding ` * arg ` or ` ** kwarg ` OR you can pass in specific values that must be used for certain parameters while letting others be auto generated . All ` * arg ` and ` ** kwargs ` are automatically passed along to ` hypothesis . strategies . builds ` to enable this . Non strategies are automatically converted to strategies using ` hypothesis . strategies . just `. Except for the following options : - * _auto_allow_exceptions * : A tuple of exceptions that are acceptable for the function to raise and will no be considered a test error . - * _auto_runs * : Number of strategies combinations to run the given function against . - * _auto_verify * : An optional callback function that will be called to allow custom verification . of the functions return value . The callback function should raise an AssertionError if the return value does not match expectations . \"\"\" return_type = get_type_hints ( _auto_function ) . get ( \" return \" , None ) strategy_args = [ arg if isinstance ( arg , SearchStrategy ) else just ( arg ) for arg in args ] strategy_kwargs = { name : value if isinstance ( value , SearchStrategy ) else just ( value ) for name , value in kwargs . items () } strategy = builds ( _auto_function , * strategy_args , ** strategy_kwargs ) for _ in range ( _auto_runs ) : try : result = strategy . example () except _auto_allow_exceptions : # type : ignore continue if return_type : class ReturnModel ( BaseModel ) : __annotations__ = { \" returns \" : return_type } ReturnModel ( returns = result ) if _auto_verify : _auto_verify ( result ) auto_test_module def auto_test_module ( module : module ) -> None Attempts to automatically test every public function within a module. View Source def auto_test_module ( module : ModuleType ) -> None : \"\"\" Attempts to automatically test every public function within a module. \"\"\" for attribute_name in dir ( module ) : if not attribute_name . startswith ( \" _ \" ) : attribute = getattr ( module , attribute_name ) if isfunction ( attribute ) : auto_test ( attribute )","title":"Tester"},{"location":"reference/hypothesis_auto/tester/#module-hypothesis_autotester","text":"View Source from inspect import isfunction from types import ModuleType from typing import Callable , Optional , Tuple , Union , get_type_hints from hypothesis.strategies import SearchStrategy , builds , just from pydantic import BaseModel def auto_test ( _auto_function : Callable , * args , _auto_allow_exceptions : Union [ Tuple [ BaseException ], Tuple ] = (), _auto_runs : int = 50 , _auto_verify : Optional [ Callable ] = None , ** kwargs ) -> None : \"\"\"A simple utility function for hypothesis that enables fully automatic testing for a type hinted callable, including return type verification. By default auto_test uses type annotations to automatically decide on strategies via the hypothesis builds strategy. You can override individual strategies by passing them in under the corresponding `*arg` or `**kwarg` OR you can pass in specific values that must be used for certain parameters while letting others be auto generated. All `*arg` and `**kwargs` are automatically passed along to `hypothesis.strategies.builds` to enable this. Non strategies are automatically converted to strategies using `hypothesis.strategies.just`. Except for the following options: - *_auto_allow_exceptions*: A tuple of exceptions that are acceptable for the function to raise and will no be considered a test error. - *_auto_runs*: Number of strategies combinations to run the given function against. - *_auto_verify*: An optional callback function that will be called to allow custom verification. of the functions return value. The callback function should raise an AssertionError if the return value does not match expectations. \"\"\" return_type = get_type_hints ( _auto_function ) . get ( \"return\" , None ) strategy_args = [ arg if isinstance ( arg , SearchStrategy ) else just ( arg ) for arg in args ] strategy_kwargs = { name : value if isinstance ( value , SearchStrategy ) else just ( value ) for name , value in kwargs . items () } strategy = builds ( _auto_function , * strategy_args , ** strategy_kwargs ) for _ in range ( _auto_runs ): try : result = strategy . example () except _auto_allow_exceptions : # type: ignore continue if return_type : class ReturnModel ( BaseModel ): __annotations__ = { \"returns\" : return_type } ReturnModel ( returns = result ) if _auto_verify : _auto_verify ( result ) def auto_test_module ( module : ModuleType ) -> None : \"\"\"Attempts to automatically test every public function within a module.\"\"\" for attribute_name in dir ( module ): if not attribute_name . startswith ( \"_\" ): attribute = getattr ( module , attribute_name ) if isfunction ( attribute ): auto_test ( attribute )","title":"Module hypothesis_auto.tester"},{"location":"reference/hypothesis_auto/tester/#functions","text":"","title":"Functions"},{"location":"reference/hypothesis_auto/tester/#auto_test","text":"def auto_test ( _auto_function : Callable , * args , _auto_allow_exceptions : Union [ Tuple [ BaseException ], Tuple ] = (), _auto_runs : int = 50 , _auto_verify : Union [ Callable , NoneType ] = None , ** kwargs ) -> None A simple utility function for hypothesis that enables fully automatic testing for a type hinted callable, including return type verification. By default auto_test uses type annotations to automatically decide on strategies via the hypothesis builds strategy. You can override individual strategies by passing them in under the corresponding *arg or **kwarg OR you can pass in specific values that must be used for certain parameters while letting others be auto generated. All *arg and **kwargs are automatically passed along to hypothesis.strategies.builds to enable this. Non strategies are automatically converted to strategies using hypothesis.strategies.just . Except for the following options: _auto_allow_exceptions : A tuple of exceptions that are acceptable for the function to raise and will no be considered a test error. _auto_runs : Number of strategies combinations to run the given function against. _auto_verify : An optional callback function that will be called to allow custom verification. of the functions return value. The callback function should raise an AssertionError if the return value does not match expectations. View Source def auto_test ( _auto_function : Callable , * args , _auto_allow_exceptions : Union [ Tuple [ BaseException ], Tuple ] = () , _auto_runs : int = 50 , _auto_verify : Optional [ Callable ] = None , ** kwargs ) -> None : \"\"\" A simple utility function for hypothesis that enables fully automatic testing for a type hinted callable , including return type verification . By default auto_test uses type annotations to automatically decide on strategies via the hypothesis builds strategy . You can override individual strategies by passing them in under the corresponding ` * arg ` or ` ** kwarg ` OR you can pass in specific values that must be used for certain parameters while letting others be auto generated . All ` * arg ` and ` ** kwargs ` are automatically passed along to ` hypothesis . strategies . builds ` to enable this . Non strategies are automatically converted to strategies using ` hypothesis . strategies . just `. Except for the following options : - * _auto_allow_exceptions * : A tuple of exceptions that are acceptable for the function to raise and will no be considered a test error . - * _auto_runs * : Number of strategies combinations to run the given function against . - * _auto_verify * : An optional callback function that will be called to allow custom verification . of the functions return value . The callback function should raise an AssertionError if the return value does not match expectations . \"\"\" return_type = get_type_hints ( _auto_function ) . get ( \" return \" , None ) strategy_args = [ arg if isinstance ( arg , SearchStrategy ) else just ( arg ) for arg in args ] strategy_kwargs = { name : value if isinstance ( value , SearchStrategy ) else just ( value ) for name , value in kwargs . items () } strategy = builds ( _auto_function , * strategy_args , ** strategy_kwargs ) for _ in range ( _auto_runs ) : try : result = strategy . example () except _auto_allow_exceptions : # type : ignore continue if return_type : class ReturnModel ( BaseModel ) : __annotations__ = { \" returns \" : return_type } ReturnModel ( returns = result ) if _auto_verify : _auto_verify ( result )","title":"auto_test"},{"location":"reference/hypothesis_auto/tester/#auto_test_module","text":"def auto_test_module ( module : module ) -> None Attempts to automatically test every public function within a module. View Source def auto_test_module ( module : ModuleType ) -> None : \"\"\" Attempts to automatically test every public function within a module. \"\"\" for attribute_name in dir ( module ) : if not attribute_name . startswith ( \" _ \" ) : attribute = getattr ( module , attribute_name ) if isfunction ( attribute ) : auto_test ( attribute )","title":"auto_test_module"}]}